
when an image changes it may break backwards compatibility of
cyber-dojo.sh for existing exercises. Images need to be tagged with
${SHA:0:7} like services. But this tag needs to end up in start_point/manifest.json
The sha depends on the commit, and if the image tag is hand written into
manifest.json it will come _before_ the commit. So...
  1) the image is tagged with ${SHA:0:7}
  2) the image tag has to get into the manifest in a post-commit automated way

How are start-point images created...
$ cyber-dojo start-point create --languages <NAME> <REPO_URL>...
This runs commander/app/sh/start-point-create.sh which git clones
each repo and stores the commit of its head into a shas.txt like this
  echo -e "${URL_INDEX} \t ${sha} \t ${url}" >> "${CONTEXT_DIR}/shas.txt"
where URL_INDEX is a simple incrementing integer.

Make each dir got its own sha.txt file (repo url too):
  echo ${sha} > "${CONTEXT_DIR}/${URL_INDEX}/start_point/sha.txt
  echo ${url} > "${CONTEXT_DIR}/${URL_INDEX}/start_point/url.txt

The cloned repos are COPY'd into the image and the start-points-base image
has CMD [ "./up.sh" ] which runs a rack-dispatcher. That uses starter.rb
which has a read_manifests() method.
1) That could tweak the image_name in each manifest from its sha.txt file...
     sha = IO.read("#{dir}/sha.txt")
     tag = sha[0...7]
     manifest['image_name'] += ":#{tag}"
     manifest['url'] = IO.read("#{dir}/url.txt").strip
2) image_build_test_push_notify.sh (the LTF build script) needs to tag the image.
   Its in cyber-dojo-tools/image_builder. See push_cdl_image_to_dockerhub()
   towards the end.
     sha="${CIRCLE_SHA1}"
     tag="${sha:0:7}"
     docker tag $(image_name) $(image_name):${tag}
     echo "${DOCKER_PASSWORD}" | docker login --username "${DOCKER_USERNAME}" --password-stdin
     docker push $(image_name):${tag}
   However, the tag will have to happen even if you are not on CI.
   It has to work on a local dev loop.

//---------------------------------------------------------------

The tag could be added to the manifests image_name when the
manifest is cached (and then returned) from a start-point service.
Note this solves the rag-lambda caching problem in runner!!!!
(As long as images are genuinely immutable)
Runner can make harvesting the text files an option.
  An manifest option - required.
  A run-time option - nice to have. Opens up possibilities for customization.

o) LTF genuine commit => CI creates and pushes image with tag based on commit
o) LTF cron job => Same, but don't push image. Fail if rag-test FAILS or check-version.sh fails.
   If passes, do a forced-commit (on its origin repo) to trigger new image with new tag.
o) start-points-base commit causes CI to create new image
     this new image saves repo URL and commit sha into dir for each docker-pulled LTF
     also has a CI cron job which
        auto-deploys and
        triggers commits in 2 dependent repos. custom/languages
          they in turn could trigger commit in 2 associated chooser repos
Also
When a new exercise is created then we could send a POST to the runner service
which would need to be a daemonset. But this would be a nice to have.
The image would still get pulled (inside runner) on the first use anyway.
And runner is a replica not a daemonset anyway.
But...
there is a difference between creating a custom-start-point and a languages-start-point.
LSP gcc (base-image)
      dir/docker and no dir/start_point
      dir/docker/image_name.json names the image.
    gcc-assert  (test-framework-image)
      dir/docker
      dir/docker/image_name.json ALSO names the image
      dir/start_point/manifest.json does NOT contain an image_name entry.
        image-name comes from dir/docker/image_name.json
CSP Tennis/Round1/manifest.json that DOES not have docker/ dir
    but more importantly, has manifes.json that does have an image_name entry.
So now...
How it seems gcc-assert/docker/Dockerfile has to explicitly name
the tag on the FROM image.
So
ESP: manifest.json
       must have "display_name"
       must have "visible_filenames"
       NO "image_name"
         image_name taken from mixed-in LSP
LSP: manifest.json
       must have "display_name"
       must have "visible_filenames"
       must have "filename_extension" <----- this is the only required difference
       NO "image_name"
         image_name taken from commit-tag which is used for image tag
CSP: manifest.json
       HASH "image_name"
         tag can be supplied, defaults to :latest

//---------------------------------------------------------------

Now there is no need for puller :)
Instead what you need re security
  is a way to prevent an exercise from running if
   - 1.it is older than a certain age. This seems the simplest default option.
   - 2.there is a later tag?
   - 3.it is marked as being a security risk?
   - 4.other possibilities...
Implies images know their own creation date.

//---------------------------------------------------------------

Also makes it easy to have a shas page with 2 tabs
- cyber-dojo for services (as now)
- cyber-dojo-languages - for LTFs. Could be several entries for an LTF each with a unique tag.
     each with duration details too. You can see if it is faster or not.
